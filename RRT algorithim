import matplotlib.pyplot as plt
from shapely.geometry import Polygon, Point, LineString
import random as rn

class RRTNode:
    def __init__(self, point):
        self.point = point
        self.parent = None

def generate_random_point():
    return Point(rn.uniform(0, 30), rn.uniform(0, 30))

def find_nearest_node(tree, point):
    nearest_node = None
    min_distance = float('inf')

    for node in tree:
        distance = node.point.distance(point)
        if distance < min_distance:
            nearest_node = node
            min_distance = distance

    return nearest_node

def is_collision_free(point, obstacles):
    for obstacle in obstacles:
        if obstacle.intersects(point):
            return False
    return True

def generate_rrt(start_point, end_point, obstacles, max_iterations=1000):
    tree = [RRTNode(start_point)]

    for _ in range(max_iterations):
        random_point = generate_random_point()
        nearest_node = find_nearest_node(tree, random_point)

        # Extend towards the random point
        direction = random_point - nearest_node.point
        length = min(1.0, direction.length)
        new_point = nearest_node.point + (direction / direction.length) * length

        if is_collision_free(LineString([nearest_node.point, new_point]), obstacles):
            new_node = RRTNode(new_point)
            new_node.parent = nearest_node
            tree.append(new_node)

            # Check if the goal is reached
            if new_point.distance(end_point) < 1.0:
                tree[-1] = RRTNode(end_point)
                tree[-1].parent = new_node
                break

    return tree

def extract_path(tree):
    path = []
    current_node = tree[-1]

    while current_node is not None:
        path.append(current_node.point)
        current_node = current_node.parent

    return path[::-1]

def plot_rrt(tree, obstacles, start_point, end_point):
    fig, ax = plt.subplots()

    # Plot obstacles
    for obstacle in obstacles:
        x, y = obstacle.exterior.xy
        ax.fill(x, y, facecolor='gray', edgecolor='black')

    # Plot RRT nodes and edges
    for node in tree:
        if node.parent is not None:
            line = LineString([node.point, node.parent.point])
            x, y = line.xy
            ax.plot(x, y, color='blue')

    # Plot start and end points
    ax.plot(start_point.x, start_point.y, marker='o', markersize=10, color='green', label='Start Point')
    ax.plot(end_point.x, end_point.y, marker='o', markersize=10, color='red', label='End Point')

    ax.set_xlim(0, 30)
    ax.set_ylim(0, 30)
    ax.set_aspect('equal', adjustable='box')  # Equal aspect ratio for x and y axes
    ax.set_xlabel('X-axis')
    ax.set_ylabel('Y-axis')
    ax.legend()

    plt.show()

if __name__ == "__main__":
    start_point = Point(5, 5)
    end_point = Point(25, 25)

    # Generate non-overlapping polygons (obstacles)
    obstacles = generate_non_overlapping_polygons(5)

    # Generate RRT
    rrt_tree = generate_rrt(start_point, end_point, obstacles)

    # Extract the path from the RRT tree
    path = extract_path(rrt_tree)

    # Plot the RRT and environment
    plot_rrt(rrt_tree, obstacles, start_point, end_point)

    # Plot the final path
    fig, ax = plt.subplots()
    for obstacle in obstacles:
        x, y = obstacle.exterior.xy
        ax.fill(x, y, facecolor='gray', edgecolor='black')

    for i in range(len(path) - 1):
        line = LineString([path[i], path[i + 1]])
        x, y = line.xy
        ax.plot(x, y, color='green', linewidth=2)

    ax.plot(start_point.x, start_point.y, marker='o', markersize=10, color='green', label='Start Point')
    ax.plot(end_point.x, end_point.y, marker='o', markersize=10, color='red', label='End Point')

    ax.set_xlim(0, 30)
    ax.set_ylim(0, 30)
    ax.set_aspect('equal', adjustable='box')  # Equal aspect ratio for x and y axes
    ax.set_xlabel('X-axis')
    ax.set_ylabel('Y-axis')
    ax.legend()

    plt.show()
